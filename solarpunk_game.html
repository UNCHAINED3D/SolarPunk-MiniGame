<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solarpunk Habitat Builder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Dark background for a clean look */
            color: #f0fdf4;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        #game-canvas {
            display: block;
            background-size: cover;
            background-position: center;
            width: 100%;
            height: 100%;
            cursor: default;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            border-bottom: 2px solid #34d399;
            z-index: 1000;
        }

        .resource-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
            font-weight: bold;
            color: #ecfdf5;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        .resource-item .main-display {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1.25rem;
        }

        .resource-item img {
            width: 32px;
            height: 32px;
        }
        
        .forecast-text {
            font-size: 0.875rem; /* Smaller text for the forecast */
        }
        .text-green-400 {
            color: #4ade80; /* Green for positive change */
        }
        .text-red-400 {
            color: #f87171; /* Red for negative change */
        }

        #message-box {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: opacity 0.3s ease-in-out;
            opacity: 0;
            z-index: 2000;
            color: #065f46;
            font-weight: bold;
            text-align: center;
        }
        
        #message-box.show {
            opacity: 1;
        }

        #controls {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
            z-index: 1000;
        }
        
        .control-button {
            padding: 0.75rem 1.5rem;
            font-weight: bold;
            border-radius: 9999px;
            color: #f0fdf4;
            background: linear-gradient(to right, #34d399, #10b981);
            border: none;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: all 0.2s;
            cursor: pointer;
        }
        .control-button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 8px -1px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .control-button:active {
            transform: scale(0.98);
        }
        .control-button.active {
            background: linear-gradient(to right, #ef4444, #b91c1c);
        }
        .build-menu {
            position: absolute;
            bottom: 6rem;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(5px);
        border: 2px solid #a7f3d0;
        border-radius: 1rem;
        padding: 1rem;
        display: flex;
        gap: 1rem;
        z-index: 1000;
        }
        .build-menu-item {
            cursor: pointer;
            text-align: center;
            padding: 0.5rem;
            border-radius: 0.75rem;
            transition: background 0.2s;
        }
        .build-menu-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        .build-menu-item img {
            width: 64px;
            height: 64px;
            border-radius: 0.5rem;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <!-- UI Overlay for Resources -->
        <div id="ui-overlay">
            <div class="flex gap-4">
                <div class="resource-item">
                    <div class="main-display">
                        <img id="money-icon" src="https://unchained3d.github.io/SolarPunk-MiniGame/money_sprite.png" alt="Money">
                        <span id="money-count">500</span>
                    </div>
                    <span id="money-forecast" class="forecast-text"></span>
                </div>
                <div class="resource-item">
                    <div class="main-display">
                        <img id="energy-icon" src="https://unchained3d.github.io/SolarPunk-MiniGame/energy_sprite.png" alt="Energy">
                        <span id="energy-count">100</span>
                    </div>
                    <span id="energy-forecast" class="forecast-text"></span>
                </div>
                <div class="resource-item">
                    <div class="main-display">
                        <img id="water-icon" src="https://unchained3d.github.io/SolarPunk-MiniGame/water_sprite.png" alt="Water">
                        <span id="water-count">50</span>
                    </div>
                    <span id="water-forecast" class="forecast-text"></span>
                </div>
                <div class="resource-item">
                    <div class="main-display">
                        <img id="food-icon" src="https://unchained3d.github.io/SolarPunk-MiniGame/food_sprite.png" alt="Food">
                        <span id="food-count">50</span>
                    </div>
                    <span id="food-forecast" class="forecast-text"></span>
                </div>
                <div class="resource-item">
                    <div class="main-display">
                        <img id="guest-icon" src="https://unchained3d.github.io/SolarPunk-MiniGame/guest_sprite.png" alt="Guest Points">
                        <span id="guest-points-count">0</span>
                    </div>
                    <span id="guest-points-forecast" class="forecast-text"></span>
                </div>
            </div>
            <div class="text-lg font-bold">
                Day: <span id="day-count">1</span>
            </div>
        </div>

        <!-- The main canvas for the game world -->
        <canvas id="game-canvas"></canvas>

        <!-- A message box for user feedback -->
        <div id="message-box"></div>

        <!-- Main control buttons -->
        <div id="controls">
            <button id="toggle-build-mode" class="control-button">Toggle Build</button>
            <button id="toggle-edit-mode" class="control-button">Toggle Move</button>
            <button id="pass-time" class="control-button">Pass 1 Day</button>
        </div>

        <!-- The build menu (hidden by default) -->
        <div id="build-menu" class="build-menu hidden">
            <!-- Garden Plot -->
            <div id="build-garden" class="build-menu-item">
                <img src="https://unchained3d.github.io/SolarPunk-MiniGame/garden_sprite.png" alt="Garden">
                <p>Garden (50M)</p>
            </div>
            <!-- Bungalow -->
            <div id="build-bungalow" class="build-menu-item">
                <img src="https://unchained3d.github.io/SolarPunk-MiniGame/bungalow_sprite.png" alt="Bungalow">
                <p>Bungalow (200M, 100GP)</p>
            </div>
            <!-- Solar Panel -->
            <div id="build-solar" class="build-menu-item">
                <img src="https://unchained3d.github.io/SolarPunk-MiniGame/solar_sprite.png" alt="Solar Panel">
                <p>Solar (100M)</p>
            </div>
            <!-- Water Pump -->
            <div id="build-water-pump" class="build-menu-item">
                <img src="https://unchained3d.github.io/SolarPunk-MiniGame/water_pump_sprite.png" alt="Water Pump">
                <p>Water Pump (75M)</p>
            </div>
            <!-- Attraction -->
            <div id="build-attraction" class="build-menu-item">
                <img src="https://unchained3d.github.io/SolarPunk-MiniGame/attraction_sprite.png" alt="Attraction">
                <p>Attraction (150M)</p>
            </div>
            <!-- Chicken Coop -->
            <div id="build-chicken-coop" class="build-menu-item">
                <img src="https://unchained3d.github.io/SolarPunk-MiniGame/chicken_coop_sprite.png" alt="Chicken Coop">
                <p>Chicken Coop (125M)</p>
            </div>
        </div>
    </div>

    <script>
        // Use a self-invoking function to prevent global scope pollution
        (function() {
            // =============================================================
            // Core Game Setup
            // =============================================================
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            
            // UI Elements
            const moneyCountEl = document.getElementById('money-count');
            const energyCountEl = document.getElementById('energy-count');
            const waterCountEl = document.getElementById('water-count');
            const foodCountEl = document.getElementById('food-count');
            const guestPointsCountEl = document.getElementById('guest-points-count');
            const dayCountEl = document.getElementById('day-count');
            const messageBoxEl = document.getElementById('message-box');

            // Forecast Elements
            const moneyForecastEl = document.getElementById('money-forecast');
            const energyForecastEl = document.getElementById('energy-forecast');
            const waterForecastEl = document.getElementById('water-forecast');
            const foodForecastEl = document.getElementById('food-forecast');
            const guestPointsForecastEl = document.getElementById('guest-points-forecast');
            
            // Control Buttons and Menus
            const toggleBuildBtn = document.getElementById('toggle-build-mode');
            const toggleEditBtn = document.getElementById('toggle-edit-mode');
            const passTimeBtn = document.getElementById('pass-time');
            const buildMenuEl = document.getElementById('build-menu');
            
            // Game State
            const state = {
                resources: {
                    money: 500,
                    energy: 100,
                    water: 50,
                    food: 50,
                    guestPoints: 0
                },
                day: 1,
                sprites: [],
                // Game modes
                isBuilding: false,
                isEditing: false,
                selectedSprite: null,
                hoveredSprite: null,
                // Pan and Zoom
                zoomLevel: 1,
                cameraOffset: { x: 0, y: 0 },
                isPanning: false,
                lastMousePosition: { x: 0, y: 0 },
                // Mobile-specific touch state
                isPinching: false,
                initialPinchDistance: 0,
            };

            // New configuration object to hold all building data
            const buildingsConfig = {
                'garden': { cost: 50, width: 96, height: 96, imgPath: 'https://unchained3d.github.io/SolarPunk-MiniGame/garden_sprite.png', info: "+10 {food} / Day\n-5 {water} / Day" },
                'bungalow': { cost: 200, guestCost: 100, width: 192, height: 192, imgPath: 'https://unchained3d.github.io/SolarPunk-MiniGame/bungalow_sprite.png', info: "Houses 2 Guests\n-10 {energy} / Day\n-5 {money} / Day\n-5 {water} / Day\n-5 {food} / Day" },
                'solar': { cost: 100, width: 96, height: 96, imgPath: 'https://unchained3d.github.io/SolarPunk-MiniGame/solar_sprite.png', info: "+20 {energy} / Day" },
                'water-pump': { cost: 75, width: 96, height: 96, imgPath: 'https://unchained3d.github.io/SolarPunk-MiniGame/water_pump_sprite.png', info: "+20 {water} / Day\n-5 {energy} / Day" },
                'attraction': { cost: 150, width: 288, height: 288, imgPath: 'https://unchained3d.github.io/SolarPunk-MiniGame/attraction_sprite.png', info: "+10 {guestPoints} / Day" },
                'chicken-coop': { cost: 125, width: 288, height: 288, imgPath: 'https://unchained3d.github.io/SolarPunk-MiniGame/chicken_coop_sprite.png', info: "+25 {money} / Day\n-5 {food} / Day" }
            };

            // Object to store pre-loaded image objects
            const assets = {};

            // =============================================================
            // Helper Functions
            // =============================================================

            // Utility function to draw a rounded rectangle
            CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius) {
                if (width < 2 * radius) radius = width / 2;
                if (height < 2 * radius) radius = height / 2;
                this.beginPath();
                this.moveTo(x + radius, y);
                this.arcTo(x + width, y, x + width, y + height, radius);
                this.arcTo(x + width, y + height, x, y + height, radius);
                this.arcTo(x, y + height, x, y, radius);
                this.arcTo(x, y, x + width, y, radius);
                this.closePath();
                return this;
            }
            
            // Function to show a message to the user
            function showMessage(text, isError = false) {
                messageBoxEl.textContent = text;
                messageBoxEl.className = 'show';
                messageBoxEl.style.backgroundColor = isError ? '#fca5a5' : '#d1fae5';
                messageBoxEl.style.color = isError ? '#7f1d1d' : '#065f46';
                setTimeout(() => {
                    messageBoxEl.className = '';
                }, 3000);
            }

            // Function to update the UI with current resource values
            function updateUI() {
                moneyCountEl.textContent = state.resources.money.toFixed(0);
                energyCountEl.textContent = state.resources.energy.toFixed(0);
                waterCountEl.textContent = state.resources.water.toFixed(0);
                foodCountEl.textContent = state.resources.food.toFixed(0);
                guestPointsCountEl.textContent = state.resources.guestPoints.toFixed(0);
                dayCountEl.textContent = state.day;

                // Update the forecast
                const forecast = calculateTomorrowForecast();
                updateForecastUI(moneyForecastEl, forecast.money);
                updateForecastUI(energyForecastEl, forecast.energy);
                updateForecastUI(waterForecastEl, forecast.water);
                updateForecastUI(foodForecastEl, forecast.food);
                updateForecastUI(guestPointsForecastEl, forecast.guestPoints);
            }

            // Function to update a single forecast element
            function updateForecastUI(element, value) {
                if (value > 0) {
                    element.textContent = `+${value.toFixed(0)}`;
                    element.className = 'forecast-text text-green-400';
                } else if (value < 0) {
                    element.textContent = `${value.toFixed(0)}`;
                    element.className = 'forecast-text text-red-400';
                } else {
                    element.textContent = '+0';
                    element.className = 'forecast-text text-green-400'; // Default to green for zero change
                }
            }

            // A reusable function to calculate daily resource changes without altering state
            function calculateDailyChanges(sprites, currentResources) {
                const changes = {
                    money: 0,
                    energy: 0,
                    water: 0,
                    food: 0,
                    guestPoints: 0
                };
            
                // Count buildings for calculations
                const solarPanels = sprites.filter(s => s.type === 'solar').length;
                const waterPumps = sprites.filter(s => s.type === 'water-pump').length;
                const gardens = sprites.filter(s => s.type === 'garden').length;
                const bungalows = sprites.filter(s => s.type === 'bungalow').length;
                const attractions = sprites.filter(s => s.type === 'attraction').length;
                const chickenCoops = sprites.filter(s => s.type === 'chicken-coop').length;
            
                // Calculate base production and consumption
                changes.energy += solarPanels * 20;
                changes.guestPoints += attractions * 10;
                changes.money += chickenCoops * 25; // Chicken coop money production
            
                // Check if enough energy for pumps
                const energyPerPump = 5;
                const energyForPumps = waterPumps * energyPerPump;
                if (currentResources.energy + changes.energy >= energyForPumps) {
                    changes.water += waterPumps * 20;
                    changes.energy -= energyForPumps;
                }
            
                // Check if enough water for gardens
                const waterPerGarden = 5;
                const waterForGardens = gardens * waterPerGarden;
                if (currentResources.water + changes.water >= waterForGardens) {
                    changes.food += gardens * 10;
                    changes.water -= waterForGardens;
                }
                
                // Chicken coop food consumption
                changes.food -= chickenCoops * 5;

                // Bungalow consumption (representing guests)
                changes.money += bungalows * 50; // Guests pay money
                changes.energy -= bungalows * 10;
                changes.water -= bungalows * 5;
                changes.food -= bungalows * 5;

                return changes;
            }

            // Function to calculate the resource forecast for the next day
            function calculateTomorrowForecast() {
                // Get the daily changes based on the current state
                const dailyChanges = calculateDailyChanges(state.sprites, state.resources);
                
                // The daily changes are the forecast, as we are not simulating further
                return dailyChanges;
            }


            // Function to draw info text for the hovered sprite
            function drawInfoText() {
                if (!state.hoveredSprite) return;

                const sprite = state.hoveredSprite;
                const infoText = buildingsConfig[sprite.type]?.info;
                if (!infoText) return;

                // Adjust info box position and size based on zoom level and offset
                const drawX = sprite.x * state.zoomLevel + state.cameraOffset.x;
                const drawY = sprite.y * state.zoomLevel + state.cameraOffset.y;
                const drawWidth = sprite.width * state.zoomLevel;
                const drawHeight = sprite.height * state.zoomLevel;

                const padding = 10 * state.zoomLevel;
                const iconSize = 16 * state.zoomLevel;
                const iconPadding = 5 * state.zoomLevel;
                const lineHeight = 20 * state.zoomLevel;
                const fontSize = 14 * state.zoomLevel;
                ctx.font = `${fontSize}px 'Inter', sans-serif`;

                const lines = infoText.split('\n');
                let maxWidth = 0;
                lines.forEach(line => {
                    const match = line.match(/{(\w+)}/);
                    const textContent = match ? line.replace(match[0], '').trim() : line;
                    const textWidth = ctx.measureText(textContent).width;
                    const totalLineWidth = match ? textWidth + iconSize + iconPadding : textWidth;
                    if (totalLineWidth > maxWidth) {
                        maxWidth = totalLineWidth;
                    }
                });

                const boxWidth = maxWidth + padding * 2;
                const boxHeight = lines.length * lineHeight + padding * 2;
                
                const boxX = drawX + drawWidth + 10 * state.zoomLevel;
                const boxY = drawY;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.roundRect(boxX, boxY, boxWidth, boxHeight, 10 * state.zoomLevel).fill();

                ctx.fillStyle = '#f0fdf4';
                lines.forEach((line, index) => {
                    const textY = boxY + padding + (index * lineHeight) + fontSize;
                    
                    const match = line.match(/{(\w+)}/);
                    if (match) {
                        const resourceType = match[1];
                        const textContent = line.replace(match[0], '').trim();
                        const icon = assets[`${resourceType}_sprite`];
                        if (icon && icon.complete) {
                            ctx.drawImage(icon, boxX + padding, textY - iconSize + 2, iconSize, iconSize);
                        }
                        ctx.fillText(textContent, boxX + padding + iconSize + iconPadding, textY);
                    } else {
                        ctx.fillText(line, boxX + padding, textY);
                    }
                });
            }

            // Function to draw all sprites on the canvas
            function drawSprites() {
                state.sprites.forEach(sprite => {
                    // Calculate drawing position and size based on zoom and camera offset
                    const drawX = sprite.x * state.zoomLevel + state.cameraOffset.x;
                    const drawY = sprite.y * state.zoomLevel + state.cameraOffset.y;
                    const drawWidth = sprite.width * state.zoomLevel;
                    const drawHeight = sprite.height * state.zoomLevel;

                    if (sprite.img.complete) {
                        ctx.drawImage(sprite.img, drawX, drawY, drawWidth, drawHeight);
                    }
                    // Draw a highlight if the sprite is selected
                    if (state.isEditing && state.selectedSprite === sprite) {
                        ctx.strokeStyle = '#ef4444';
                        ctx.lineWidth = 4 * state.zoomLevel;
                        ctx.strokeRect(drawX, drawY, drawWidth, drawHeight);
                    }
                });
            }

            // The main game drawing function
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw the background image, scaled to fit the canvas without stretching
                if (assets.backdrop && assets.backdrop.complete) {
                    const backdrop = assets.backdrop;
                    const backdropRatio = backdrop.width / backdrop.height;
                    const canvasRatio = canvas.width / canvas.height;
                    let drawWidth, drawHeight;

                    // Fit the backdrop to the canvas while maintaining aspect ratio
                    if (backdropRatio > canvasRatio) {
                        drawWidth = canvas.width;
                        drawHeight = canvas.width / backdropRatio;
                    } else {
                        drawWidth = canvas.height * backdropRatio;
                        drawHeight = canvas.height;
                    }
                    
                    // Apply zoom and pan to the backdrop
                    const finalWidth = drawWidth * state.zoomLevel;
                    const finalHeight = drawHeight * state.zoomLevel;
                    const offsetX = state.cameraOffset.x + (canvas.width - finalWidth) / 2;
                    const offsetY = state.cameraOffset.y + (canvas.height - finalHeight) / 2;

                    ctx.drawImage(backdrop, offsetX, offsetY, finalWidth, finalHeight);
                }

                drawSprites();
                drawInfoText(); // Draw the info box after the sprites
            }
            
            // Function to advance the game by one day
            function passTime() {
                state.day++;
                
                // Get the daily changes from the reusable function
                const dailyChanges = calculateDailyChanges(state.sprites, state.resources);
                
                // Apply the changes to the game state
                state.resources.money += dailyChanges.money;
                state.resources.energy += dailyChanges.energy;
                state.resources.water += dailyChanges.water;
                state.resources.food += dailyChanges.food;
                state.resources.guestPoints += dailyChanges.guestPoints;

                // Check for game over conditions
                if (state.resources.energy < 0 || state.resources.water < 0 || state.resources.food < 0) {
                    showMessage("Game Over! Your resources ran out. Refresh to restart.", true);
                    return;
                }

                showMessage(`Day ${state.day}: The habitat's balance has been updated.`);
                updateUI();
                draw();
            }
            
            // =============================================================
            // User Interaction Functions
            // =============================================================
            
            // Handles building new sprites
            function handleBuild(type) {
                const config = buildingsConfig[type];
                
                // Check for bungalow cost, including guest points
                if (type === 'bungalow') {
                    if (state.resources.money >= config.cost && state.resources.guestPoints >= config.guestCost) {
                        state.resources.money -= config.cost;
                        state.resources.guestPoints -= config.guestCost;
                    } else {
                        showMessage(`Not enough resources to build a ${type.replace('-', ' ')}. (Need ${config.cost}M and ${config.guestCost}GP)`, true);
                        return;
                    }
                } else if (state.resources.money >= config.cost) {
                    state.resources.money -= config.cost;
                } else {
                    showMessage(`Not enough money to build a ${type.replace('-', ' ')}. (Need ${config.cost}M)`, true);
                    return;
                }

                const newSprite = {
                    id: Date.now(),
                    type,
                    x: (canvas.width / 2 - config.width / 2 - state.cameraOffset.x) / state.zoomLevel, // Center the new sprite, accounting for pan/zoom
                    y: (canvas.height / 2 - config.height / 2 - state.cameraOffset.y) / state.zoomLevel,
                    width: config.width,
                    height: config.height,
                    level: 1,
                    img: assets[type] // Get the pre-loaded image from the assets object
                };
                state.sprites.push(newSprite);
                showMessage(`Built a new ${type.replace('-', ' ')}!`);
                updateUI(); // This will also update the forecast
                draw();
            }

            // Handles upgrading a selected sprite
            function handleUpgrade() {
                const sprite = state.selectedSprite;
                if (!sprite) return;

                let upgradeCost = 0;
                if (sprite.type === 'garden') {
                    if (sprite.level === 1) upgradeCost = 100;
                    if (state.resources.money >= upgradeCost) {
                        state.resources.money -= upgradeCost;
                        sprite.level++;
                        showMessage(`Upgraded the ${sprite.type.replace('-', ' ')} to level ${sprite.level}!`);
                        updateUI();
                        draw();
                    } else {
                        showMessage("Not enough money to upgrade.", true);
                    }
                } else {
                    showMessage("This item cannot be upgraded (yet).", true);
                }
            }
            
            // =============================================================
            // Event Listeners for both Mouse and Touch
            // =============================================================
            
            // Helper to get coordinates from mouse or touch event
            function getEventCoords(e) {
                if (e.touches && e.touches.length > 0) {
                    return { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
                return { x: e.clientX, y: e.clientY };
            }
            
            // Helper to get distance between two touches
            function getPinchDistance(e) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            // Canvas resize handler
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                draw();
            }
            window.addEventListener('resize', resizeCanvas);
            
            // Mouse & Touch Down
            canvas.addEventListener('mousedown', handlePointerDown);
            canvas.addEventListener('touchstart', handlePointerDown);
            
            function handlePointerDown(e) {
                e.preventDefault();
                const coords = getEventCoords(e);

                if (e.touches && e.touches.length === 2) {
                    // Start of a pinch gesture
                    state.isPinching = true;
                    state.initialPinchDistance = getPinchDistance(e);
                    state.isPanning = false;
                } else if (e.touches && e.touches.length === 1 || e.button === 0) {
                    // Start of a drag/pan gesture with one finger or left mouse button
                    state.isPinching = false;
                    
                    const mouseX = coords.x;
                    const mouseY = coords.y;
                    
                    // Adjust mouse coordinates for pan and zoom
                    const adjustedX = (mouseX - state.cameraOffset.x) / state.zoomLevel;
                    const adjustedY = (mouseY - state.cameraOffset.y) / state.zoomLevel;

                    // Check for sprite selection in edit mode
                    if (state.isEditing) {
                        const clickedSprite = state.sprites.find(sprite =>
                            adjustedX >= sprite.x && adjustedX <= sprite.x + sprite.width &&
                            adjustedY >= sprite.y && adjustedY <= sprite.y + sprite.height
                        );
                        
                        if (clickedSprite) {
                            state.selectedSprite = clickedSprite;
                            state.dragOffset = { x: mouseX - clickedSprite.x * state.zoomLevel, y: mouseY - clickedSprite.y * state.zoomLevel };
                            canvas.style.cursor = 'grabbing';
                        } else {
                            state.selectedSprite = null; // Deselect if clicking empty space
                            state.isPanning = true;
                            state.lastMousePosition = { x: mouseX, y: mouseY };
                            canvas.style.cursor = 'grabbing';
                            draw();
                        }
                    } else {
                        state.isPanning = true;
                        state.lastMousePosition = { x: mouseX, y: mouseY };
                        canvas.style.cursor = 'grabbing';
                    }
                }
            }
            
            // Mouse & Touch Move
            canvas.addEventListener('mousemove', handlePointerMove);
            canvas.addEventListener('touchmove', handlePointerMove);

            function handlePointerMove(e) {
                e.preventDefault();

                if (state.isPinching && e.touches && e.touches.length === 2) {
                    // Pinch-to-zoom logic
                    const newPinchDistance = getPinchDistance(e);
                    const zoomFactor = newPinchDistance / state.initialPinchDistance;

                    const oldZoom = state.zoomLevel;
                    state.zoomLevel *= zoomFactor;
                    state.zoomLevel = Math.max(0.5, Math.min(state.zoomLevel, 3)); // Clamp zoom level

                    // Adjust camera offset to zoom towards the center of the pinch
                    const pinchCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                    const pinchCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                    const zoomChange = state.zoomLevel - oldZoom;
                    state.cameraOffset.x -= (pinchCenterX - state.cameraOffset.x) * (zoomChange / oldZoom);
                    state.cameraOffset.y -= (pinchCenterY - state.cameraOffset.y) * (zoomChange / oldZoom);

                    state.initialPinchDistance = newPinchDistance; // Update for next frame
                    draw();
                } else if (state.isPanning && !state.isPinching) {
                    // Pan logic
                    const coords = getEventCoords(e);
                    const dx = coords.x - state.lastMousePosition.x;
                    const dy = coords.y - state.lastMousePosition.y;
                    state.cameraOffset.x += dx;
                    state.cameraOffset.y += dy;
                    state.lastMousePosition = { x: coords.x, y: coords.y };
                    draw();
                } else if (state.selectedSprite) { // Drag logic for a selected sprite
                    const coords = getEventCoords(e);
                    state.selectedSprite.x = (coords.x - state.dragOffset.x) / state.zoomLevel;
                    state.selectedSprite.y = (coords.y - state.dragOffset.y) / state.zoomLevel;
                    draw();
                }

                // Check for hovered sprite for info box
                const coords = getEventCoords(e);
                const adjustedX = (coords.x - state.cameraOffset.x) / state.zoomLevel;
                const adjustedY = (coords.y - state.cameraOffset.y) / state.zoomLevel;
                const hovered = state.sprites.find(sprite =>
                    adjustedX >= sprite.x && adjustedX <= sprite.x + sprite.width &&
                    adjustedY >= sprite.y && adjustedY <= sprite.y + sprite.height
                );
                state.hoveredSprite = hovered;
                
                // Update cursor for hovering only when not in build or edit mode and not panning
                if (!state.isPanning) {
                    canvas.style.cursor = hovered ? 'pointer' : 'default';
                }

                draw();
            }
            
            // Mouse & Touch Up
            canvas.addEventListener('mouseup', handlePointerUp);
            canvas.addEventListener('touchend', handlePointerUp);
            canvas.addEventListener('touchcancel', handlePointerUp); // Also handle touchcancel

            function handlePointerUp(e) {
                state.isPanning = false;
                state.isPinching = false;
                state.selectedSprite = null;
                canvas.style.cursor = state.isEditing ? 'grab' : 'default';
            }
            
            // Mouse wheel for zooming (desktop only)
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomFactor = 1.1;
                const mouseX = e.clientX;
                const mouseY = e.clientY;
                const oldZoom = state.zoomLevel;

                if (e.deltaY < 0) {
                    state.zoomLevel *= zoomFactor;
                } else {
                    state.zoomLevel /= zoomFactor;
                }

                state.zoomLevel = Math.max(0.5, Math.min(state.zoomLevel, 3));

                const zoomChange = state.zoomLevel - oldZoom;
                const mouseCanvasX = mouseX - canvas.getBoundingClientRect().left;
                const mouseCanvasY = mouseY - canvas.getBoundingClientRect().top;
                state.cameraOffset.x -= (mouseCanvasX - state.cameraOffset.x) * (zoomChange / oldZoom);
                state.cameraOffset.y -= (mouseCanvasY - state.cameraOffset.y) * (zoomChange / oldZoom);

                draw();
            });

            // Key press handler for upgrades (desktop only)
            document.addEventListener('keydown', (e) => {
                if (e.key === 'U' || e.key === 'u') {
                    handleUpgrade();
                }
            });

            // Control button handlers
            toggleBuildBtn.addEventListener('click', () => {
                state.isBuilding = !state.isBuilding;
                buildMenuEl.classList.toggle('hidden', !state.isBuilding);
                toggleBuildBtn.classList.toggle('active', state.isBuilding);
                state.isEditing = false;
                toggleEditBtn.classList.remove('active');
                state.selectedSprite = null;
                state.hoveredSprite = null;
                canvas.style.cursor = state.isBuilding ? 'crosshair' : 'default';
                draw();
            });

            toggleEditBtn.addEventListener('click', () => {
                state.isEditing = !state.isEditing;
                toggleEditBtn.classList.toggle('active', state.isEditing);
                state.isBuilding = false;
                toggleBuildBtn.classList.remove('active');
                buildMenuEl.classList.add('hidden');
                state.hoveredSprite = null;
                canvas.style.cursor = state.isEditing ? 'grab' : 'default';
                draw();
            });
            
            passTimeBtn.addEventListener('click', passTime);

            // Build menu item handlers
            document.getElementById('build-garden').addEventListener('click', () => handleBuild('garden'));
            document.getElementById('build-bungalow').addEventListener('click', () => handleBuild('bungalow'));
            document.getElementById('build-solar').addEventListener('click', () => handleBuild('solar'));
            document.getElementById('build-water-pump').addEventListener('click', () => handleBuild('water-pump'));
            document.getElementById('build-attraction').addEventListener('click', () => handleBuild('attraction'));
            document.getElementById('build-chicken-coop').addEventListener('click', () => handleBuild('chicken-coop'));

            // =============================================================
            // Initialization
            // =============================================================
            // New function to pre-load all images before starting the game.
            function preloadImages(callback) {
                const imgPaths = [
                    'https://unchained3d.github.io/SolarPunk-MiniGame/backdrop.jpg',
                    'https://unchained3d.github.io/SolarPunk-MiniGame/money_sprite.png',
                    'https://unchained3d.io/SolarPunk-MiniGame/energy_sprite.png',
                    'https://unchained3d.github.io/SolarPunk-MiniGame/water_sprite.png',
                    'https://unchained3d.github.io/SolarPunk-MiniGame/food_sprite.png',
                    'https://unchained3d.github.io/SolarPunk-MiniGame/guest_sprite.png',
                    ...Object.values(buildingsConfig).map(b => b.imgPath)
                ];
                let loadedCount = 0;
                const totalImages = imgPaths.length;
                
                // Helper function to load a single image and check if all are done
                function loadImage(path, key) {
                    const img = new Image();
                    img.onload = () => {
                        loadedCount++;
                        if (loadedCount === totalImages) {
                            callback();
                        }
                    };
                    img.src = path;
                    assets[key] = img;
                }

                // Load all images dynamically
                loadImage('https://unchained3d.github.io/SolarPunk-MiniGame/backdrop.jpg', 'backdrop');
                loadImage('https://unchained3d.github.io/SolarPunk-MiniGame/money_sprite.png', 'money_sprite');
                loadImage('https://unchained3d.github.io/SolarPunk-MiniGame/energy_sprite.png', 'energy_sprite');
                loadImage('https://unchained3d.github.io/SolarPunk-MiniGame/water_sprite.png', 'water_sprite');
                loadImage('https://unchained3d.github.io/SolarPunk-MiniGame/food_sprite.png', 'food_sprite');
                loadImage('https://unchained3d.github.io/SolarPunk-MiniGame/guest_sprite.png', 'guest_sprite');
                for (const type in buildingsConfig) {
                    loadImage(buildingsConfig[type].imgPath, type);
                }
            }

            // The main initialization function
            function init() {
                updateUI();
                // Preload all images and then set up the canvas
                preloadImages(() => {
                    resizeCanvas();
                    draw();
                });
            }

            init();

        })();
    </script>
</body>
</html>
